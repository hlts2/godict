package godict

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"os"
	"unsafe"

	// TODO: The assets directory was generated by https://github.com/jessevdk/go-assets.
	// If go1.16 will be released, we can use go embed function instead of go assets generation.
	// So I will delete after go1.16 is released.
	"github.com/hlts2/godict/assets"

	"golang.org/x/sync/errgroup"
)

const (
	defaultDictionaryName = "dict.txt"
)

type Dictionary interface {
	Do(ctx context.Context, fn func(pattern string)) error
}

type dictionary struct {
	paths []string
}

func New(opts ...Option) (Dictionary, error) {
	d := new(dictionary)
	for _, opt := range append(defaultOpts, opts...) {
		if err := opt(d); err != nil {
			return nil, fmt.Errorf("failed to apply option: %w", err)
		}
	}
	return d, nil
}

func (d *dictionary) Do(ctx context.Context, fn func(pattern string)) error {
	opens := make([]func() (io.ReadCloser, error), 0, len(d.paths)+1)
	opens = append(opens, func() (io.ReadCloser, error) {
		return assets.Root.Open(defaultDictionaryName)
	})

	for _, path := range d.paths {
		opens = append(opens, func() (io.ReadCloser, error) {
			return os.Open(path)
		})
	}

	eg, egctx := errgroup.WithContext(ctx)

	for _, open := range opens {
		open := open
		eg.Go(func() error {
			return d.do(egctx, open, fn)
		})
	}

	return eg.Wait()
}

func (d *dictionary) do(ctx context.Context, open func() (io.ReadCloser, error), fn func(pattern string)) error {
	f, err := open()
	if err != nil {
		return err
	}
	defer f.Close()

	reader := bufio.NewReader(f)

	for {
		select {
		case _ = <-ctx.Done():
			return ctx.Err()
		default:
		}

		line, _, err := reader.ReadLine()
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}

		fn(*(*string)(unsafe.Pointer(&line)))
	}

	return nil
}
